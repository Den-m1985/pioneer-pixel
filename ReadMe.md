## Необходимо написать приложение

### Стек и тулы:

- [x] База данных Postgres
- [ ] Использование Redis/Elastic и т.д. для определенных целей – на ваше усмотрение.
- [x] Java 11 версии и выше
- [x] Имплементация на Spring boot.
- [x] REST API.
- [x] Сборка: Maven

### Общие требование к системе:

- [x] 3 слоя – API, service, DAO
- [x] Будем считать, что в системе только обычные пользователи (не админы и т.д).
- [x] Будем считать, что пользователи создаются миграциями (не будем усложнять). Просто считаем, что для обычных пользователей нет операции создания. Для тестов создать напрямую в DAO.
- [x] У пользователя может быть более одного PHONE_DATA (должен быть как минимум 1).
- [x] У пользователя может быть более одного EMAIL_DATA (должен быть как минимум 1).
- [x] У пользователя должен быть быть строго один ACCOUNT.
- [x] Начальный BALANCE в ACCOUNT указывается при создании пользователя.
- [x] BALANCE в ACCOUNT не может уходить в минус ни при каких операциях.
- [x] Валидация входных API данных.

### Обязательные фичи:

- [ ] Добавить корректное кэширование (например на API и на DAO слой). Имплементация на ваше усмотрение. 
- [x] CREATE (только для определенных внутри пользователя данных), UPDATE операции для пользователя. Пользователь может менять только собственные данные:
        a) может удалить/сменить/добавить email если он не занят другим пользователям
        b) может удалить/сменить/добавить phone если он не занят другим пользователям
        c) остальное менять не может
- [x] Реализовать READ операцию для пользователей. Сделать «поиск пользователей» (искать может любой любого) с фильтрацией по полям ниже и пагинацией (size, page/offset): 
        a) Если передана «dateOfBirth», то фильтр записей, где «date_of_birth» больше чем переданный в запросе.
        b) Если передан «phone», то фильтр по 100% сходству.
        c) Если передан «name», то фильтр по like форматом ‘{text-from-request-param}%’
        d) Если передан «email», то фильтр по 100% сходству.
- [x] Добавить JWT token (необходимый Claim только USER_ID), механизм получения токена на ваше усмотрение. Имплементировать максимально просто, не стоит усложнять. Аутентификация может быть по email+password, либо по phone+password.
- [ ] Раз в 30 секунд BALANCE каждого клиента увеличиваются на 10% но не более 207% от начального депозита.
Например:  
Было: 100, стало: 110.  
Было: 110, стало:121.  
…
- [ ] Сделать функционал трансфер денег от одного пользователя к другому.
Вход: USER_ID (transfer from) – берем у авторизованного из Claim токена, USER_ID (transfer to) из запроса, VALUE (сумма перевода) из запроса.
То есть у того, кто переводит мы списываем эту сумму, у того, кому переводим – добавляем эту сумму.
Считать эту операцию «банковской» (высоко-значимой), сделать ее со всеми нужными валидациями (надо подумать какими) и потоко-защищенной.

### Не обязательные фичи (но которые очень хотелось бы видеть, хотя бы в минимальном исполнении):

- [x] Добавить swagger (минимальную конфигурацию).
- [x] Добавить не бездумное (значимое) логгирование.

### Тестирование:

- [x] Покрытие unit тестами. Не надо покрывать тестами весь код. Нужно сделать тесты на покрытие функционала трансфера денег и какую-то API операцию покрыть через testcontainers с использованием MockMvc.